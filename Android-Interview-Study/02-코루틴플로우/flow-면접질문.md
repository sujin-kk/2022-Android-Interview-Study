## Flow 예상 면접 질문

---

### 🍎 Q. Flow에 대한 간단한 설명?

### 🍏 A. 
- 일회성 데이터 전달이 아닌, 데이터가 변경될 때 이벤트를 발생시켜서 데이터를 계속해서 전달하도록 하는 프로그래밍 방식인 리액티브 프로그래밍에서,
Producer가 Consumer에게 **지속적으로 데이터를 전달**하는데, 이것을 **Data Stream**이라고 합니다.
- 플로우는 코루틴 상에서 이 데이터 스트림을 구현하기 위한 구성요소 입니다.

---

### 🍎 Q. Flow의 세가지 구성요소와 각각에 대한 간단한 설명?

### 🍏 A. 

- producer / intermediary / consumer로 구성
- 생산자 - 데이터를 가져옴, 최신데이터를 가져옴 emit으로 데이터 생성, 시간을 정해서 반복해서 가져올 수있음
- 중간연산자 - 데이터를 수정/가공 예외처리할수있음, map/filter/onEach 주로 사용, 레포지토리에서 가져와 처리함
- 소비자 - 뷰모델 부분에서 가져와 처리할수있음. 뷰모델 스코프 런치를 활용해 collect

---

### **🍎 Q. Flow를 어떨때 쓰는지? or Flow의 장점**

### 🍏 A. 

데이터를 콜백으로 처리해야 한다던가, 데이터를 스트림으로 받아야 하는 상황에서는 Flow 를 적극적으로 사용하는 것이 좋을 것 같습니다.

Flow 를 사용하면 데이터 관련 콜백 리스너를 만들지 않아도 되고, 데이터 변형, 에러 처리 등 다양한 API 를 제공하고 있기 때문에 Flow는 다양한 상황에서 활용 가치가 높다고 생각합니다.

---

### 🍎 Q. 라이브데이터와 Flow의 차이?

### 🍏 A. 

둘다 관찰 가능한 데이터 홀더 타입이라는 공통점을 가집니다.

라이브 데이터는 안드로이드의 수명 주기를 인식할 수 있어 메모리 누수를 방지할 수 있는 장점등을 가지지만, 비동기 데이터 스트림을 지원하지 않아 오직 Main Thread에서만 실행되어 뷰 작업 이외의 데이터 호출/처리 작업등에 대한 성능 저하 단점이 있습니다.

플로우는 반대로 비동기 데이터 스트림을 지원하여 값을 지속적으로 관찰할 수 있지만, 생명주기를 인식하지 못하는 단점이 존재합니다. 하지만 순수 코틀린을 지원하는 클래스로써 안드로이드 os에 종속적이지 않아 데이터 레이어에서 사용하기에 좋다는 장점이 있습니다. 

--- 

### 🍎 Q. Flow가 클린 아키텍처 관점에서의 “LiveData의 한계를 해결해준다” 이외의 느끼는 장점이 따로 있는지?

### 🍏 A. 

- StateFlow, SharedFlow 가 LiveData 대비 이점이 있는 것은 비단 아키텍처 관점 뿐만이 아니라,
LiveData 는 기본적으로 메인 쓰레드에서 값을 캐싱하도록 되어있는 것에 비해 Flow 는 다양한 쓰레드에서 데이터 처리가 가능합니다.
또한 Flow의 다양한 API를 통해 풍부한 활용이 가능한 것도 장점입니다.

--- 

### 🍎 Q. Flow는 데이터를 수집할 순 있지만 저장할 순 없는데, 어떤식으로 해결할 수 있는지?


### 🍏 A. 
1. 화면이 재구성 될때마다 다시 서버 or DB로부터 데이터 가져오기
    
    -> 이는 비효율적인데 예를들어, 화면이 회전되면 onDestory가 호출된 후 다시 onCreate가 호출되는데,
    이때마다 새로운 데이터를 서버나 DB로부터 가져와야하는 문제점,,
    
2. Flow로 부터 collect한 데이터를 ViewModel에 저장해놓고 사용하기
    
    → flow를 구독하고, **데이터 홀더 변수는 flow에서 마지막으로 발행한 데이터를 저장**하고 있으면 됨, 서버로 다시 
    요청 필요 없음
    
    
    → But, UIState가 여러개이고, 모두를 구독하기 위해 비슷한 코드를 매번 작성해야한다 ? 이는 Boiler Plate,,,
    
- 그래서 StateFlow를 이용하여 해결할 수 있음.
- 
- **데이터 홀더(저장소) 역할을 하면서 Flow의 데이터 스트림 역할까지 함**
- 항상 값을 갖고 있고, 오직 하나의 값을 가짐
- **Hot Stream 방식**으로 collector가 없어도 생성 시 바로 활성화되며, 값이 업데이트 된 경우에만 반환
- 여러개의 collector를 지원하기 때문에 중복 리소스 요청을 방지

---


### 🍎 Q. Flow가 안전하게 수집 해제되는 시점을 어떻게 조절할건지?

### 🍏 A. 

- CoroutineScope 를 액티비티나 뷰모델(lifecycleScope / viewModelScope)에 잘 할당해주고 해제해 줄수 있어야 합니다.

onDestroy시에 collect가 중단되기 때문에, 앱이 종료되지 않고 백그라운드에 남아있으면 collect가 해제되지 않아 메모리 누수가 날 수 있습니다. 

그래서 수명 주기를 인식하여 onStart에서 Job 생성을 시작하고 onStop에서 Job을 캔슬하여 데이터 수집을 중단하는 repeatOnLifecycle 함수를 제공하여 조절할 수 있습니다. 이 함수는 1회성 setup task에 적합합니다.

오직 1개의 flow만 collect할 경우 flowWithLifecycle을 사용하면 좋습니다.

---

### 🍎 Q. flowWithLifecycle에 대한 질문

[[안드로이드] 빠르게 개발하려면 flowWithLifecycle](https://keelim.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A0%A4%EB%A9%B4-flowWithLifecycle?category=1080005)

### 🍎 Q. flow를 통해 데이터를 받아 올 때 예외처리를 어떻게 하면 좋을지? or 발생하는 예외에 대한 처리 경험?
### 🍎 Q. collect와 collectLatest 차이?
### 🍎 Q. Flow와 StateFlow 차이?
### 🍎 Q. StateFlow와 SharedFlow 차이?


--- 

좋은 말인것 같아서,,

> StateFlow 는 Flow 를 통해 발행된 스트림 데이터 중 가장 마지막 값을 캐싱 하는 것일 뿐임.
> 
> RxJava 도 마찬가지지만, 스트림 데이터를 처리하는 기본적인 컨셉은 데이터 공급자는 데이터 소비자(구독자)에게 데이터를 보내고 끝임.
> 
> 보내진 데이터를 어떻게 처리하느냐는 구독자의 역할이며, StateFlow 처럼 최신 값을 캐싱하는 것 또한 다양한 데이터 처리 방법 중 하나일 뿐.
> 
> 개발을 하다보면 요구사항에 따라 Stream 데이터를 캐싱하지 않고 그때그때 처리할 일이 많음. 보존(캐싱)은 그 처리하는 다양한 방법 중 하나이다!
> 

